// server.js
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const compression = require('compression');
const morgan = require('morgan');
const basicAuth = require('express-basic-auth');

const app = express();
const PORT = process.env.PORT || 3000;
const PROXY_TARGET = process.env.PROXY_TARGET || 'https://example-game-server.com';
const PREFIX = process.env.PROXY_PREFIX || '/';
const ENABLE_BASIC_AUTH = process.env.ENABLE_BASIC_AUTH === 'true';
const BASIC_USER = process.env.BASIC_USER || 'admin';
const BASIC_PASS = process.env.BASIC_PASS || 'changeme';
const CACHE_MAX_AGE = parseInt(process.env.CACHE_MAX_AGE || '300', 10); // seconds

// Logging
app.use(morgan('tiny'));

// Security
app.use(helmet({
  contentSecurityPolicy: false, // adjust if you need CSP
}));
app.use(compression());

// Optional basic auth (good for private dev proxies)
if (ENABLE_BASIC_AUTH) {
  app.use(basicAuth({
    users: { [BASIC_USER]: BASIC_PASS },
    challenge: true,
  }));
}

// Rate limiter (basic protection)
const limiter = rateLimit({
  windowMs: 15 * 1000, // 15s
  max: parseInt(process.env.RATE_MAX || '200', 10), // requests per window per IP
  standardHeaders: true,
  legacyHeaders: false,
});
app.use(limiter);

// Simple health check
app.get('/_health', (req, res) => res.json({ ok: true, target: PROXY_TARGET }));

// Optional route to serve a tiny index (useful if Railway expects a web app)
app.get('/', (req, res, next) => {
  if (process.env.SERVE_STATIC === 'true') {
    return res.sendFile(require('path').join(__dirname, 'public', 'index.html'));
  }
  res.type('text').send(`Game proxy running. Proxying -> ${PROXY_TARGET}`);
});

// Proxy options
const proxyOptions = {
  target: PROXY_TARGET,
  changeOrigin: true,
  ws: true, // enable WebSocket proxying
  logLevel: process.env.PROXY_LOG_LEVEL || 'warn',
  onProxyReq(proxyReq, req, res) {
    // Example: pass original host header or set custom headers
    proxyReq.setHeader('x-forwarded-host', req.headers.host);
    // If the backend expects a specific host, override it:
    // proxyReq.setHeader('host', new URL(PROXY_TARGET).host);
  },
  onProxyRes(proxyRes, req, res) {
    // Add simple cache-control for static assets
    const ct = proxyRes.headers['content-type'] || '';
    if (/\/(javascript|css|image|font)|text\/(css|javascript)/i.test(ct)) {
      proxyRes.headers['cache-control'] = `public, max-age=${CACHE_MAX_AGE}`;
    }
  },
  pathRewrite: (path, req) => {
    // If you want to strip a prefix (e.g. /api -> /)
    if (PREFIX && PREFIX !== '/' && path.startsWith(PREFIX)) {
      return path.replace(PREFIX, '/');
    }
    return path;
  },
  onError(err, req, res) {
    console.error('Proxy error:', err && err.message);
    if (!res.headersSent) {
      res.status(502).json({ error: 'Bad Gateway', details: err && err.message });
    }
  },
};

// Mount proxy on desired path. default: everything under /proxy/* -> target
const mountPath = process.env.MOUNT_PATH || '/proxy';
app.use(mountPath, createProxyMiddleware(proxyOptions));

// Also optionally proxy everything (careful) if PROXY_ALL=true
if (process.env.PROXY_ALL === 'true') {
  app.use('/', createProxyMiddleware(proxyOptions));
}

// Start server and support WebSocket upgrades
const server = app.listen(PORT, () => {
  console.log(`Proxy running on port ${PORT}`);
  console.log(`Proxy target: ${PROXY_TARGET}`);
  console.log(`Mount path: ${mountPath}`);
});

// For http-proxy-middleware, ws: true is enough — no extra handlers needed for Express server
server.on('upgrade', function (req, socket, head) {
  // this is here mainly to show we accept upgrades — http-proxy-middleware handles it
  console.log('Upgrade (ws) request for', req.url);
});
